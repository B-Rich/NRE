From 8bb4a0310e5e4c387e78dd6164a5a0e0aa761461 Mon Sep 17 00:00:00 2001
From: Nils Asmussen <nils@os.inf.tu-dresden.de>
Date: Thu, 19 Jul 2012 15:27:59 +0200
Subject: [PATCH 4/4] Added a small interactive kernel debugger

---
 include/config.h         |    2 +-
 include/console_vga.h    |    4 +
 include/debugger.h       |   47 +++++++++++
 include/debugger_cmds.h  |   36 +++++++++
 include/debugger_kb.h    |  162 +++++++++++++++++++++++++++++++++++++
 include/debugger_kbdrv.h |   32 ++++++++
 include/ec.h             |    2 +
 include/kobject.h        |   45 ++++++++++-
 include/lapic.h          |    4 +
 include/sm.h             |    4 +
 include/vectors.h        |    1 +
 src/console_vga.cpp      |    5 ++
 src/debugger.cpp         |  198 +++++++++++++++++++++++++++++++++++++++++++++
 src/debugger_cmds.cpp    |  179 +++++++++++++++++++++++++++++++++++++++++
 src/debugger_kb.cpp      |  199 ++++++++++++++++++++++++++++++++++++++++++++++
 src/debugger_kbdrv.cpp   |  173 ++++++++++++++++++++++++++++++++++++++++
 src/keyb.cpp             |    4 +
 src/lapic.cpp            |    9 +++
 src/kobject.cpp          |   15 +++++++++++++++
 19 files changed, 1118 insertions(+), 3 deletions(-)
 create mode 100644 include/debugger.h
 create mode 100644 include/debugger_cmds.h
 create mode 100644 include/debugger_kb.h
 create mode 100644 include/debugger_kbdrv.h
 create mode 100644 src/debugger.cpp
 create mode 100644 src/debugger_cmds.cpp
 create mode 100644 src/debugger_kb.cpp
 create mode 100644 src/debugger_kbdrv.cpp
 create mode 100644 src/kobject.cpp

diff --git a/include/config.h b/include/config.h
index f891bd1..35de999 100644
--- a/include/config.h
+++ b/include/config.h
@@ -29,7 +29,7 @@
 #define NUM_GSI         128
 #define NUM_LVT         6
 #define NUM_MSI         1
-#define NUM_IPI         2
+#define NUM_IPI         3
 
 #define SPN_SCH         0
 #define SPN_HLP         1
diff --git a/include/console_vga.h b/include/console_vga.h
index 95fb4fe..87f06ab 100644
--- a/include/console_vga.h
+++ b/include/console_vga.h
@@ -25,8 +25,12 @@
 #include "memory.h"
 #include "string.h"
 
+class Debugger;
+
 class Console_vga : public Console
 {
+	friend class Debugger;
+
     private:
         enum Register
         {
diff --git a/include/debugger.h b/include/debugger.h
new file mode 100644
index 0000000..fb173f1
--- /dev/null
+++ b/include/debugger.h
@@ -0,0 +1,47 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#pragma once
+
+#include "debugger_kb.h"
+#include "console_vga.h"
+
+#define ENABLE_KOBJ_LIST	1
+
+class Debugger {
+	typedef int (*cmd_func)(size_t argc,char **argv);
+
+	enum {
+		MAX_ARG_COUNT	= 5,
+		MAX_ARG_LEN		= 32,
+		MAX_SEARCH_LEN	= 16,
+		HISTORY_SIZE	= 32,
+		VID_COLS		= 80,
+	};
+
+	struct Command {
+		const char *name;
+		cmd_func exec;
+	};
+
+	static char **read_command(size_t *argc);
+	static char *read_line(void);
+	static Command *get_command(const char *name);
+	static void reprint_line(const char *line,size_t len);
+
+public:
+	static void start();
+
+private:
+	static size_t hist_wpos;
+	static size_t hist_rpos;
+	static size_t hist_size;
+	static char history[HISTORY_SIZE][VID_COLS + 1];
+	static Command cmds[];
+};
diff --git a/include/debugger_cmds.h b/include/debugger_cmds.h
new file mode 100644
index 0000000..0f6e0ec
--- /dev/null
+++ b/include/debugger_cmds.h
@@ -0,0 +1,36 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#pragma once
+
+#include "types.h"
+#include "debugger.h"
+#include "kobject.h"
+
+class Ec;
+
+class Debugger_cmds {
+private:
+	static void print_backtrace(Ec *ec);
+	static int atoi(const char *nptr);
+	template<class T>
+	static T *get_kobj(Kobject::Type t,unsigned id);
+
+	static const char *kobj_types[];
+
+public:
+	static int caps(size_t argc,char **argv);
+#if ENABLE_KOBJ_LIST
+	static int pds(size_t argc,char **argv);
+	static int ecs(size_t argc,char **argv);
+	static int scs(size_t argc,char **argv);
+	static int sms(size_t argc,char **argv);
+	static int pts(size_t argc,char **argv);
+#endif
+};
diff --git a/include/debugger_kb.h b/include/debugger_kb.h
new file mode 100644
index 0000000..c888def
--- /dev/null
+++ b/include/debugger_kb.h
@@ -0,0 +1,162 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#pragma once
+
+#include "types.h"
+
+class Debugger_kb {
+	public:
+		struct KeyEvent {
+			uint8 keycode;
+			char character;
+			uint8 flags;
+		};
+
+		enum Type {
+			PRESS			= 1,
+			RELEASE			= 2,
+		};
+
+		enum Modifier {
+			SHIFT			= 1,
+			CTRL			= 2,
+			ALT				= 4,
+			BREAK			= 8,
+		};
+
+		enum Keys {
+			VK_NOKEY		= 128,
+			VK_ACCENT		= 1,
+			VK_0			= 2,
+			VK_1			= 3,
+			VK_2			= 4,
+			VK_3			= 5,
+			VK_4			= 6,
+			VK_5			= 7,
+			VK_6			= 8,
+			VK_7			= 9,
+			VK_8			= 10,
+			VK_9			= 11,
+			VK_MINUS		= 12,
+			VK_EQ			= 13,
+			VK_BACKSP		= 15,
+			VK_TAB			= 16,
+			VK_Q			= 17,
+			VK_W			= 18,
+			VK_E			= 19,
+			VK_R			= 20,
+			VK_T			= 21,
+			VK_Y			= 22,
+			VK_U			= 23,
+			VK_I			= 24,
+			VK_O			= 25,
+			VK_P			= 26,
+			VK_LBRACKET		= 27,
+			VK_RBRACKET		= 28,
+			VK_BACKSLASH	= 29,
+			VK_CAPS			= 30,
+			VK_A			= 31,
+			VK_S			= 32,
+			VK_D			= 33,
+			VK_F			= 34,
+			VK_G			= 35,
+			VK_H			= 36,
+			VK_J			= 37,
+			VK_K			= 38,
+			VK_L			= 39,
+			VK_SEM			= 40,
+			VK_APOS			= 41,
+			/* non-US-1 ?? */
+			VK_ENTER		= 43,
+			VK_LSHIFT		= 44,
+			VK_Z			= 46,
+			VK_X			= 47,
+			VK_C			= 48,
+			VK_V			= 49,
+			VK_B			= 50,
+			VK_N			= 51,
+			VK_M			= 52,
+			VK_COMMA		= 53,
+			VK_DOT			= 54,
+			VK_SLASH		= 55,
+			VK_RSHIFT		= 57,
+			VK_LCTRL		= 58,
+			VK_LSUPER		= 59,
+			VK_LALT			= 60,
+			VK_SPACE		= 61,
+			VK_RALT			= 62,
+			VK_APPS			= 63,	/* ?? */
+			VK_RCTRL		= 64,
+			VK_RSUPER		= 65,
+			VK_INSERT		= 75,
+			VK_DELETE		= 76,
+			VK_HOME			= 80,
+			VK_END			= 81,
+			VK_PGUP			= 85,
+			VK_PGDOWN		= 86,
+			VK_LEFT			= 79,
+			VK_UP			= 83,
+			VK_DOWN			= 84,
+			VK_RIGHT		= 89,
+			VK_NUM			= 90,
+			VK_KP7			= 91,
+			VK_KP4			= 92,
+			VK_KP1			= 93,
+			VK_KPDIV		= 95,
+			VK_KP8			= 96,
+			VK_KP5			= 97,
+			VK_KP2			= 98,
+			VK_KP0			= 99,
+			VK_KPMUL		= 100,
+			VK_KP9			= 101,
+			VK_KP6			= 102,
+			VK_KP3			= 103,
+			VK_KPDOT		= 104,
+			VK_KPSUB		= 105,
+			VK_KPADD		= 106,
+			VK_KPENTER		= 108,
+			VK_ESC			= 110,
+			VK_F1			= 112,
+			VK_F2			= 113,
+			VK_F3			= 114,
+			VK_F4			= 115,
+			VK_F5			= 116,
+			VK_F6			= 117,
+			VK_F7			= 118,
+			VK_F8			= 119,
+			VK_F9			= 120,
+			VK_F10			= 121,
+			VK_F11			= 122,
+			VK_F12			= 123,
+			VK_PRINT		= 124,
+			VK_SCROLL		= 125,
+			VK_PAUSE		= 126,
+			VK_PIPE			= 127,
+		};
+
+		static bool get(KeyEvent *ev,unsigned events,bool wait);
+
+	private:
+		struct KeymapEntry {
+			char def;
+			char shift;
+			char alt;
+		};
+
+		static bool translate(KeyEvent *ev,uint8 scanCode);
+		static uint8 toggle_flag(bool isbreak,uint8 val,uint8 flag) {
+			if(isbreak)
+				return val & ~flag;
+			return val | flag;
+		}
+
+		static uint8 flags;
+		static KeymapEntry keymap[];
+};
diff --git a/include/debugger_kbdrv.h b/include/debugger_kbdrv.h
new file mode 100644
index 0000000..ead7b22
--- /dev/null
+++ b/include/debugger_kbdrv.h
@@ -0,0 +1,32 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#pragma once
+
+#include "types.h"
+
+class Debugger_kbdrv {
+private:
+	enum {
+		PORT_KB_DATA		= 0x60,
+		PORT_KB_CTRL		= 0x64,
+		STATUS_OUTBUF_FULL	= 1 << 0
+	};
+
+	struct ScanCodeEntry {
+		uint8 def;
+		uint8 ext;
+	};
+
+	static ScanCodeEntry map[];
+	static uint8 set;
+
+public:
+	static uint8 get(uint8 *flags);
+};
diff --git a/include/ec.h b/include/ec.h
index 10d895c..7354d5b 100644
--- a/include/ec.h
+++ b/include/ec.h
@@ -30,10 +30,12 @@
 #include "tss.h"
 
 class Utcb;
+class Debugger_cmds;
 
 class Ec : public Kobject, public Refcount, public Queue<Sc>
 {
     friend class Queue<Ec>;
+    friend class Debugger_cmds;
 
     private:
         void        (*cont)() ALIGNED (16);
diff --git a/include/kobject.h b/include/kobject.h
index 6c79a7c..03b8d43 100644
--- a/include/kobject.h
+++ b/include/kobject.h
@@ -22,13 +22,39 @@
 
 #include "mdb.h"
 #include "refptr.h"
+#include "stdio.h"
+#include "debugger.h"
+#include "spinlock.h"
+#include "lock_guard.h"
+
+class Debugger_cmds;
 
 class Kobject : public Mdb
 {
+	friend class Debugger_cmds;
+
+    private:
+#if ENABLE_KOBJ_LIST
+    public:
+		Kobject *			dbgprev;
+        Kobject *			dbgnext;
     private:
+        static Spinlock		dbglock[5];
+        static Kobject *	dbgecs[5];
+#endif
+
         uint8 objtype;
 
-        static void free (Rcu_elem *) {}
+        static void free (Rcu_elem *e) {
+#if ENABLE_KOBJ_LIST
+        	Kobject *k = static_cast<Kobject*>(e);
+        	Lock_guard<Spinlock> guard(dbglock[k->type()]);
+        	if(k->dbgnext)
+        		k->dbgnext->dbgprev = k->dbgprev;
+        	if(k->dbgprev)
+        		k->dbgprev->dbgnext = k->dbgnext;
+#endif
+		}
 
     protected:
         Spinlock lock;
@@ -43,11 +69,26 @@ class Kobject : public Mdb
             INVALID,
         };
 
-        explicit Kobject (Type t, Space *s, mword b, mword a = perm) : Mdb (s, reinterpret_cast<mword>(this), b, a, free), objtype (t) {}
+        explicit Kobject (Type t, Space *s, mword b, mword a = perm) : Mdb (s, reinterpret_cast<mword>(this), b, a, free), objtype (t) {
+#if ENABLE_KOBJ_LIST
+        	Lock_guard<Spinlock> guard(dbglock[t]);
+        	dbgprev = 0;
+        	dbgnext = dbgecs[t];
+        	if(dbgecs[t])
+        		dbgecs[t]->dbgprev = this;
+        	dbgecs[t] = this;
+#endif
+		}
 
     public:
         static mword const perm = 0x1f;
 
+#if ENABLE_KOBJ_LIST
+        static Kobject *list(Type t) {
+        	return dbgecs[t];
+        }
+#endif
+
         ALWAYS_INLINE
         inline Type type() const
         {
diff --git a/include/lapic.h b/include/lapic.h
index 1f62f64..450199d 100644
--- a/include/lapic.h
+++ b/include/lapic.h
@@ -23,6 +23,7 @@
 #include "compiler.h"
 #include "config.h"
 #include "memory.h"
+#include "spinlock.h"
 
 class Lapic
 {
@@ -111,6 +112,9 @@ class Lapic
         static unsigned freq_bus;
         static uint8    apic_id[NUM_CPU];
 
+		static Spinlock	  spin;
+		static unsigned spincount;
+
         ALWAYS_INLINE
         static unsigned find_cpu (unsigned apic)
         {
diff --git a/include/sm.h b/include/sm.h
index 583cdfc..0e66140 100644
--- a/include/sm.h
+++ b/include/sm.h
@@ -22,8 +22,12 @@
 
 #include "ec.h"
 
+class Debugger_cmds;
+
 class Sm : public Kobject, public Queue<Ec>
 {
+	friend class Debugger_cmds;
+
     private:
         mword counter;
 
diff --git a/include/vectors.h b/include/vectors.h
index fac3b3b..d174db3 100644
--- a/include/vectors.h
+++ b/include/vectors.h
@@ -35,3 +35,4 @@
 
 #define VEC_IPI_RRQ     (VEC_IPI + 0)
 #define VEC_IPI_RKE     (VEC_IPI + 1)
+#define VEC_IPI_SPIN    (VEC_IPI + 2)
diff --git a/src/console_vga.cpp b/src/console_vga.cpp
index bca9d73..61735f3 100644
--- a/src/console_vga.cpp
+++ b/src/console_vga.cpp
@@ -53,6 +53,11 @@ void Console_vga::setup()
 
 void Console_vga::putc (int c)
 {
+	if (EXPECT_FALSE (c == '\r')) {
+		col = 0;
+		return;
+	}
+
     if (EXPECT_FALSE (c == '\f')) {
         clear_all();
         row = col = 0;
diff --git a/src/debugger.cpp b/src/debugger.cpp
new file mode 100644
index 0000000..bd4441f
--- /dev/null
+++ b/src/debugger.cpp
@@ -0,0 +1,198 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#include "config.h"
+#include "vectors.h"
+#include "types.h"
+#include "lapic.h"
+#include "ec.h"
+#include "hip.h"
+#include "debugger.h"
+#include "debugger_cmds.h"
+#include "string.h"
+#include "util.h"
+
+size_t Debugger::hist_wpos = 0;
+size_t Debugger::hist_rpos = 0;
+size_t Debugger::hist_size = 0;
+char Debugger::history[Debugger::HISTORY_SIZE][Debugger::VID_COLS + 1];
+
+Debugger::Command Debugger::cmds[] = {
+	{"help",NULL},
+	{"exit",NULL},
+#if ENABLE_KOBJ_LIST
+	{"pds",Debugger_cmds::pds},
+	{"ecs",Debugger_cmds::ecs},
+	{"scs",Debugger_cmds::scs},
+	{"sms",Debugger_cmds::sms},
+	{"pts",Debugger_cmds::pts},
+	{"caps",Debugger_cmds::caps},
+#endif
+};
+
+static size_t strlen(const char *str) {
+	size_t i = 0;
+	while(*str++)
+		i++;
+	return i;
+}
+
+void Debugger::start(void) {
+	size_t i,argc;
+	int res;
+	Command *cmd;
+	char **argv;
+
+	// we want to be alone here
+	Lapic::spincount = 0;
+	Lapic::spin.lock();
+	// notify all other CPUs via IPI
+	for(unsigned cpu = 0; cpu < NUM_CPU; cpu++) {
+		if(cpu != Ec::current->cpu && !Hip::cpu_online(cpu))
+			continue;
+		Lapic::send_ipi(cpu,VEC_IPI_SPIN);
+	}
+	// wait until they are spinning
+	while(Lapic::spincount != Cpu::online - 1)
+		pause();
+
+	Console_vga::con.clear_all();
+	Console::print("Welcome to the debugging console!\nType 'help' to get a list of commands!\n");
+
+	hist_wpos = hist_rpos = hist_size = 0;
+	memset(history,0,sizeof(history));
+
+	while(true) {
+		Console_vga::con.putc('#');
+		Console_vga::con.putc(' ');
+
+		argv = read_command(&argc);
+		Console::print("");
+
+		if(argc == 0)
+			continue;
+		if(strcmp(argv[0],"exit") == 0)
+			break;
+		if(strcmp(argv[0],"help") == 0) {
+			Console::print("Available commands:");
+			for(i = 0; i < sizeof(cmds) / sizeof(cmds[0]); i++)
+				Console::print("  %s",cmds[i].name);
+			Console::print("");
+			Console::print("All commands use a viewer, that supports the following key-strokes:");
+			Console::print(" - up/down/pageup/pagedown/home/end: navigate through the data");
+			Console::print(" - left/right: to previous/next search result");
+			Console::print(" - esc: quit");
+		}
+		else {
+			cmd = get_command(argv[0]);
+			if(cmd) {
+				res = cmd->exec(argc,argv);
+				if(res != 0)
+					Console::print("Executing command '%s' failed: %d",argv[0],res);
+			}
+			else
+				Console::print("Unknown command '%s'",argv[0]);
+		}
+	}
+
+	// now the other CPUs can continue
+	Lapic::spin.unlock();
+}
+
+char **Debugger::read_command(size_t *argc) {
+	static char argvals[MAX_ARG_COUNT][MAX_ARG_LEN];
+	static char *args[MAX_ARG_COUNT];
+	size_t i = 0,j = 0;
+	char *line = read_line();
+	args[0] = argvals[0];
+	while(*line) {
+		if(*line == ' ') {
+			if(i > 0) {
+				if(j + 1 >= MAX_ARG_COUNT)
+					break;
+				args[j][i] = '\0';
+				j++;
+				i = 0;
+				args[j] = argvals[j];
+			}
+		}
+		else if(i < MAX_ARG_LEN)
+			args[j][i++] = *line;
+		line++;
+	}
+	if(i > 0) {
+		*argc = j + 1;
+		args[j][i] = '\0';
+	}
+	else
+		*argc = j;
+	return args;
+}
+
+char *Debugger::read_line(void) {
+	static char line[VID_COLS + 1];
+	size_t i = 0;
+	Debugger_kb::KeyEvent ev;
+	while(true) {
+		Debugger_kb::get(&ev,Debugger_kb::PRESS,true);
+		if(i >= sizeof(line) - 1 || ev.keycode == Debugger_kb::VK_ENTER)
+			break;
+		if((ev.keycode == Debugger_kb::VK_UP || ev.keycode == Debugger_kb::VK_DOWN) && hist_size > 0) {
+			if(ev.keycode == Debugger_kb::VK_UP) {
+				if(hist_rpos == 0)
+					hist_rpos = hist_size - 1;
+				else
+					hist_rpos = (hist_rpos - 1) % hist_size;
+			}
+			else
+				hist_rpos = (hist_rpos + 1) % hist_size;
+			if(history[hist_rpos]) {
+				memcpy(line,history[hist_rpos],sizeof(line));
+				i = strlen(line);
+				reprint_line(line,i);
+			}
+		}
+		else if(ev.keycode == Debugger_kb::VK_BACKSP) {
+			if(i > 0) {
+				line[--i] = '\0';
+				reprint_line(line,i);
+			}
+		}
+		else if(ev.character >= ' ' && ev.character <= 'z') {
+			Console_vga::con.putc(ev.character);
+			line[i++] = ev.character;
+		}
+	}
+	line[i] = '\0';
+	memcpy(history[hist_wpos],line,sizeof(line));
+	hist_wpos = (hist_wpos + 1) % HISTORY_SIZE;
+	hist_rpos = hist_wpos;
+	hist_size = min<size_t>(hist_size + 1,HISTORY_SIZE);
+	return line;
+}
+
+void Debugger::reprint_line(const char *line,size_t len) {
+	Console_vga::con.putc('\r');
+	for(size_t c = 0; c < VID_COLS - 1; ++c)
+		Console_vga::con.putc(' ');
+	Console_vga::con.putc('\r');
+	Console_vga::con.putc('#');
+	Console_vga::con.putc(' ');
+	for(size_t c = 0; c < len; ++c)
+		Console_vga::con.putc(line[c]);
+}
+
+Debugger::Command *Debugger::get_command(const char *name) {
+	size_t i;
+	for(i = 0; i < sizeof(cmds) / sizeof(cmds[0]); i++) {
+		if(strcmp(cmds[i].name,name) == 0)
+			return cmds + i;
+	}
+	return NULL;
+}
diff --git a/src/debugger_cmds.cpp b/src/debugger_cmds.cpp
new file mode 100644
index 0000000..5a3d103
--- /dev/null
+++ b/src/debugger_cmds.cpp
@@ -0,0 +1,179 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#include "debugger_cmds.h"
+#include "console.h"
+#include "kobject.h"
+#include "pd.h"
+#include "ec.h"
+#include "sc.h"
+#include "sm.h"
+#include "pt.h"
+#include "bits.h"
+
+#if ENABLE_KOBJ_LIST
+
+const char *Debugger_cmds::kobj_types[] = {
+	"Pd","Ec","Sc","Pt","Sm"
+};
+
+void Debugger_cmds::print_backtrace(Ec *ec) {
+	mword end,start;
+	size_t count = 0;
+	mword bp = ec->sys_regs()->REG(bp);
+	if(!bp)
+		return;
+
+	Pd *old = Pd::current;
+	ec->pd->make_current();
+	end = align_up(bp,PAGE_SIZE);
+	start = end - PAGE_SIZE;
+	// make sure that we don't try to access the stack if the page isn't present
+	Paddr phys = 0;
+	if(ec->pd->Space_mem::lookup(start,phys)) {
+		for(int i = 0; i < 16; i++) {
+			// don't leave that page
+			if(bp < start || bp >= end)
+				break;
+			mword addr = *(reinterpret_cast<mword*>(bp) + 1) - 5;
+			Console::print("    %p",addr);
+			bp = *reinterpret_cast<mword*>(bp);
+		}
+	}
+	else
+		Console::print("    - Not accessible -");
+	old->make_current();
+}
+
+int Debugger_cmds::atoi(const char *nptr) {
+	bool neg = false;
+	if(*nptr == '-') {
+		neg = true;
+		nptr++;
+	}
+
+	char c;
+	int i = 0;
+	while((c = *nptr)) {
+		i = i * 10 + c - '0';
+		nptr++;
+	}
+
+	/* switch sign? */
+	if(neg)
+		i = -i;
+	return i;
+}
+
+int Debugger_cmds::caps(size_t argc,char **argv) {
+	if(argc != 2 && argc != 3)
+		return 1;
+	Pd *old = Pd::current;
+	Pd *pd = get_kobj<Pd>(Kobject::PD,atoi(argv[1]));
+	if(!pd)
+		return 1;
+	pd->make_current();
+	size_t limit = argc == 3 ? atoi(argv[2]) : 10000;
+	for(size_t i = 0; i < limit; ++i) {
+		Capability cap = pd->Space_obj::lookup(i);
+		if(cap.obj()->type() != Kobject::INVALID) {
+			Console::print("%u: type:%s obj:%p perm:%#x",
+					i,kobj_types[cap.obj()->type()],cap.obj(),cap.prm());
+		}
+	}
+	old->make_current();
+	return 0;
+}
+
+template<class T>
+T *Debugger_cmds::get_kobj(Kobject::Type t,unsigned id) {
+	Kobject *k = Kobject::list(t);
+	while(k != 0 && id-- > 0)
+		k = k->dbgnext;
+	return static_cast<T*>(k);
+}
+
+int Debugger_cmds::pds(size_t,char **) {
+	Kobject *k = Kobject::list(Kobject::PD);
+	size_t id = 0;
+	while(k != 0) {
+		Pd *pd = static_cast<Pd*>(k);
+		Console::print("[%lu] %p: %c%c%c",id,pd,
+				pd == &Pd::kern ? 'k' : '-',
+				pd == &Pd::root ? 'r' : '-',
+				pd == Pd::current ? 'c' : '-');
+		k = k->dbgnext;
+		id++;
+	}
+	return 0;
+}
+
+int Debugger_cmds::ecs(size_t,char **) {
+	Kobject *k = Kobject::list(Kobject::EC);
+	size_t id = 0;
+	while(k != 0) {
+		Ec *e = static_cast<Ec*>(k);
+		Console::print("[%lu] %p: cpu:%u PD:%p glb:%d blk:%d",id,e,e->cpu,(Pd*)(e->pd),e->glb,e->blocked());
+		if(e->sys_regs()->REG(bp)) {
+			Console::print("  Backtrace:");
+			print_backtrace(e);
+		}
+		k = k->dbgnext;
+		id++;
+	}
+	return 0;
+}
+
+int Debugger_cmds::scs(size_t,char **) {
+	Kobject *k = Kobject::list(Kobject::SC);
+	size_t id = 0;
+	while(k != 0) {
+		Sc *s = static_cast<Sc*>(k);
+		Console::print("[%lu] %p: cpu:%u EC:%p prio:%2u budget:%8x time:%12llx %c",id,s,
+				s->cpu,(Ec*)(s->ec),s->prio,s->budget,s->time,s == Sc::current ? 'c' : '-');
+		k = k->dbgnext;
+		id++;
+	}
+	return 0;
+}
+
+int Debugger_cmds::sms(size_t,char **) {
+	Kobject *k = Kobject::list(Kobject::SM);
+	size_t id = 0;
+	while(k != 0) {
+		Sm *s = static_cast<Sm*>(k);
+		Console::print("[%lu] %p: value:%u queue:",id,s,s->counter);
+		Ec *head = s->head();
+		Ec *ec = head;
+		if(ec) {
+			do {
+				Console::print("  %p",ec);
+				ec = ec->next;
+			}
+			while(ec != head);
+		}
+		k = k->dbgnext;
+		id++;
+	}
+	return 0;
+}
+
+int Debugger_cmds::pts(size_t,char **) {
+	Kobject *k = Kobject::list(Kobject::PT);
+	size_t id = 0;
+	while(k != 0) {
+		Pt *pt = static_cast<Pt*>(k);
+		Console::print("[%lu] %p: EC:%p mtd:%x ip:%p",id,pt,(Ec*)(pt->ec),pt->mtd.val,pt->ip);
+		k = k->dbgnext;
+		id++;
+	}
+	return 0;
+}
+
+#endif
diff --git a/src/debugger_kb.cpp b/src/debugger_kb.cpp
new file mode 100644
index 0000000..ec7aabc
--- /dev/null
+++ b/src/debugger_kb.cpp
@@ -0,0 +1,199 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#include "debugger_kb.h"
+#include "debugger_kbdrv.h"
+
+Debugger_kb::KeymapEntry Debugger_kb::keymap[] = {
+	/* --- */					{'\0','\0','\0'},
+	/* VK_ACCENT ( ° ) */		{'^','\xF8','\0'},
+	/* VK_0 */					{'0','=','}'},
+	/* VK_1 */					{'1','!','\0'},
+	/* VK_2 ( ² ) */			{'2','"','\xFD'},
+	/* VK_3 ( § and ³ ) */		{'3','\x15','\0'},
+	/* VK_4 */					{'4','$','\0'},
+	/* VK_5 */					{'5','%','\0'},
+	/* VK_6 */					{'6','&','\0'},
+	/* VK_7 */					{'7','/','{'},
+	/* VK_8 */					{'8','(','['},
+	/* VK_9 */					{'9',')',']'},
+	/* VK_MINUS ( ß ) */		{'\xE1','?','\\'},
+	/* VK_EQ */					{'\'','`','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_BACKSP */				{'\b','\b','\0'},
+	/* VK_TAB */				{'\t','\t','\0'},
+	/* VK_Q */					{'q','Q','@'},
+	/* VK_W */					{'w','W','\0'},
+	/* VK_E ( € ) */			{'e','E','\0'},
+	/* VK_R */					{'r','R','\0'},
+	/* VK_T */					{'t','T','\0'},
+	/* VK_Y */					{'z','Z','\0'},
+	/* VK_U */					{'u','U','\0'},
+	/* VK_I */					{'i','I','\0'},
+	/* VK_O */					{'o','O','\0'},
+	/* VK_P */					{'p','P','\0'},
+	/* VK_LBRACKET (ü and Ü) */ {'\x81','\x9A','\0'},
+	/* VK_RBRACKET */			{'+','*','~'},
+	/* VK_BACKSLASH */			{'#','\'','\0'},
+	/* VK_CAPS */				{'\0','\0','\0'},
+	/* VK_A */					{'a','A','\0'},
+	/* VK_S */					{'s','S','\0'},
+	/* VK_D */					{'d','D','\0'},
+	/* VK_F */					{'f','F','\0'},
+	/* VK_G */					{'g','G','\0'},
+	/* VK_H */					{'h','H','\0'},
+	/* VK_J */					{'j','J','\0'},
+	/* VK_K */					{'k','K','\0'},
+	/* VK_L */					{'l','L','\0'},
+	/* VK_SEM ( ö and Ö ) */	{'\x94','\x99','\0'},
+	/* VK_APOS ( ä and Ä ) */	{'\x84','\x8E','\0'},
+	/* non-US-1 */				{'\0','\0','\0'},
+	/* VK_ENTER */				{'\n','\n','\0'},
+	/* VK_LSHIFT */				{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_Z */					{'y','Y','\0'},
+	/* VK_X */					{'x','X','\0'},
+	/* VK_C */					{'c','C','\0'},
+	/* VK_V */					{'v','V','\0'},
+	/* VK_B */					{'b','B','\0'},
+	/* VK_N */					{'n','N','\0'},
+	/* VK_M ( µ ) */			{'m','M','\xE6'},
+	/* VK_COMMA */				{',',';','\0'},
+	/* VK_DOT */				{'.',':','\0'},
+	/* VK_SLASH */				{'-','_','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_RSHIFT */				{'\0','\0','\0'},
+	/* VK_LCTRL */				{'\0','\0','\0'},
+	/* VK_LSUPER */				{'\0','\0','\0'},
+	/* VK_LALT */				{'\0','\0','\0'},
+	/* VK_SPACE */				{' ',' ','\0'},
+	/* VK_RALT */				{'\0','\0','\0'},
+	/* VK_APPS */				{'\0','\0','\0'},
+	/* VK_RCTRL */				{'\0','\0','\0'},
+	/* VK_RSUPER */				{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_INSERT */				{'\0','\0','\0'},
+	/* VK_DELETE */				{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_LEFT */				{'\0','\0','\0'},
+	/* VK_HOME */				{'\0','\0','\0'},
+	/* VK_END */				{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_UP */					{'\0','\0','\0'},
+	/* VK_DOWN */				{'\0','\0','\0'},
+	/* VK_PGUP */				{'\0','\0','\0'},
+	/* VK_PGDOWN */				{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_RIGHT */				{'\0','\0','\0'},
+	/* VK_NUM */				{'\0','\0','\0'},
+	/* VK_KP7 */				{'7','7','\0'},
+	/* VK_KP4 */				{'4','4','\0'},
+	/* VK_KP1 */				{'1','1','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_KPDIV */				{'/','/','\0'},
+	/* VK_KP8 */				{'8','8','\0'},
+	/* VK_KP5 */				{'5','5','\0'},
+	/* VK_KP2 */				{'2','2','\0'},
+	/* VK_KP0 */				{'0','0','\0'},
+	/* VK_KPMUL */				{'*','*','\0'},
+	/* VK_KP9 */				{'9','9','\0'},
+	/* VK_KP6 */				{'6','6','\0'},
+	/* VK_KP3 */				{'3','3','\0'},
+	/* VK_KPDOT */				{'.','.','\0'},
+	/* VK_KPSUB */				{'-','-','\0'},
+	/* VK_KPADD */				{'+','+','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_KPENTER */			{'\n','\n','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_ESC */				{'\0','\0','\0'},
+	/* --- */					{'\0','\0','\0'},
+	/* VK_F1 */					{'\0','\0','\0'},
+	/* VK_F2 */					{'\0','\0','\0'},
+	/* VK_F3 */					{'\0','\0','\0'},
+	/* VK_F4 */					{'\0','\0','\0'},
+	/* VK_F5 */					{'\0','\0','\0'},
+	/* VK_F6 */					{'\0','\0','\0'},
+	/* VK_F7 */					{'\0','\0','\0'},
+	/* VK_F8 */					{'\0','\0','\0'},
+	/* VK_F9 */					{'\0','\0','\0'},
+	/* VK_F10 */				{'\0','\0','\0'},
+	/* VK_F11 */				{'\0','\0','\0'},
+	/* VK_F12 */				{'\0','\0','\0'},
+	/* VK_PRINT */				{'\0','\0','\0'},
+	/* VK_SCROLL */				{'\0','\0','\0'},
+	/* VK_PAUSE */				{'\0','\0','\0'},
+	/* VK_PIPE */				{'<','>','|'},
+};
+uint8 Debugger_kb::flags = 0;
+
+bool Debugger_kb::get(KeyEvent *ev,unsigned events,bool wait) {
+	while(true) {
+		uint8 keycode = Debugger_kbdrv::get(&flags);
+		if(keycode == VK_NOKEY) {
+			if(!wait)
+				break;
+			while((keycode = Debugger_kbdrv::get(&flags)) == VK_NOKEY)
+				;
+		}
+
+		/* key pressed/released */
+		if(translate(ev,keycode)) {
+			if(((flags & BREAK) && (events & RELEASE)) ||
+				(!(flags & BREAK) && (events & PRESS)))
+				return true;
+		}
+	}
+	return false;
+}
+
+bool Debugger_kb::translate(KeyEvent *ev,uint8 keycode) {
+	KeymapEntry *km;
+	if(ev)
+		ev->keycode = keycode;
+
+	/* handle shift,ctrl,alt */
+	km = keymap + keycode;
+	switch(keycode) {
+		case VK_LSHIFT:
+		case VK_RSHIFT:
+			flags = toggle_flag(flags & BREAK,flags,SHIFT);
+			break;
+		case VK_LALT:
+		case VK_RALT:
+			flags = toggle_flag(flags & BREAK,flags,ALT);
+			break;
+		case VK_LCTRL:
+		case VK_RCTRL:
+			flags = toggle_flag(flags & BREAK,flags,CTRL);
+			break;
+	}
+	if(ev)
+		ev->flags = flags;
+
+	/* fetch char from keymap */
+	if(ev) {
+		if(flags & SHIFT)
+			ev->character = km->shift;
+		else if(flags & ALT)
+			ev->character = km->alt;
+		else
+			ev->character = km->def;
+	}
+	return true;
+}
diff --git a/src/debugger_kbdrv.cpp b/src/debugger_kbdrv.cpp
new file mode 100644
index 0000000..0b4700f
--- /dev/null
+++ b/src/debugger_kbdrv.cpp
@@ -0,0 +1,173 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#include "debugger_kbdrv.h"
+#include "debugger_kb.h"
+#include "io.h"
+
+Debugger_kbdrv::ScanCodeEntry Debugger_kbdrv::map[] = {
+	/* 00 */	{0,							0},
+	/* 01 */	{Debugger_kb::VK_ESC,		0},
+	/* 02 */	{Debugger_kb::VK_1,			0},
+	/* 03 */	{Debugger_kb::VK_2,			0},
+	/* 04 */	{Debugger_kb::VK_3,			0},
+	/* 05 */	{Debugger_kb::VK_4,			0},
+	/* 06 */	{Debugger_kb::VK_5,			0},
+	/* 07 */	{Debugger_kb::VK_6,			0},
+	/* 08 */	{Debugger_kb::VK_7,			0},
+	/* 09 */	{Debugger_kb::VK_8,			0},
+	/* 0A */	{Debugger_kb::VK_9,			0},
+	/* 0B */	{Debugger_kb::VK_0,			0},
+	/* 0C */	{Debugger_kb::VK_MINUS,		0},
+	/* 0D */	{Debugger_kb::VK_EQ,		0},
+	/* 0E */	{Debugger_kb::VK_BACKSP,	0},
+	/* 0F */	{Debugger_kb::VK_TAB,		0},
+	/* 10 */	{Debugger_kb::VK_Q,			0},
+	/* 11 */	{Debugger_kb::VK_W,			0},
+	/* 12 */	{Debugger_kb::VK_E,			0},
+	/* 13 */	{Debugger_kb::VK_R,			0},
+	/* 14 */	{Debugger_kb::VK_T,			0},
+	/* 15 */	{Debugger_kb::VK_Y,			0},
+	/* 16 */	{Debugger_kb::VK_U,			0},
+	/* 17 */	{Debugger_kb::VK_I,			0},
+	/* 18 */	{Debugger_kb::VK_O,			0},
+	/* 19 */	{Debugger_kb::VK_P,			0},
+	/* 1A */	{Debugger_kb::VK_LBRACKET,	0},
+	/* 1B */	{Debugger_kb::VK_RBRACKET,	0},
+	/* 1C */	{Debugger_kb::VK_ENTER,		Debugger_kb::VK_KPENTER},
+	/* 1D */	{Debugger_kb::VK_LCTRL,		Debugger_kb::VK_RCTRL},
+	/* 1E */	{Debugger_kb::VK_A,			0},
+	/* 1F */	{Debugger_kb::VK_S,			0},
+	/* 20 */	{Debugger_kb::VK_D,			0},
+	/* 21 */	{Debugger_kb::VK_F,			0},
+	/* 22 */	{Debugger_kb::VK_G,			0},
+	/* 23 */	{Debugger_kb::VK_H,			0},
+	/* 24 */	{Debugger_kb::VK_J,			0},
+	/* 25 */	{Debugger_kb::VK_K,			0},
+	/* 26 */	{Debugger_kb::VK_L,			0},
+	/* 27 */	{Debugger_kb::VK_SEM,		0},
+	/* 28 */	{Debugger_kb::VK_APOS,		0},
+	/* 29 */	{Debugger_kb::VK_ACCENT,	0},
+	/* 2A */	{Debugger_kb::VK_LSHIFT,	0},
+	/* 2B */	{Debugger_kb::VK_BACKSLASH,	0},
+	/* 2C */	{Debugger_kb::VK_Z,			0},
+	/* 2D */	{Debugger_kb::VK_X,			0},
+	/* 2E */	{Debugger_kb::VK_C,			0},
+	/* 2F */	{Debugger_kb::VK_V,			0},
+	/* 30 */	{Debugger_kb::VK_B,			0},
+	/* 31 */	{Debugger_kb::VK_N,			0},
+	/* 32 */	{Debugger_kb::VK_M,			0},
+	/* 33 */	{Debugger_kb::VK_COMMA,		0},
+	/* 34 */	{Debugger_kb::VK_DOT,		0},
+	/* 35 */	{Debugger_kb::VK_SLASH,		Debugger_kb::VK_KPDIV},
+	/* 36 */	{Debugger_kb::VK_RSHIFT,	0},
+	/* 37 */	{Debugger_kb::VK_KPMUL,		0},
+	/* 38 */	{Debugger_kb::VK_LALT,		Debugger_kb::VK_RALT},
+	/* 39 */	{Debugger_kb::VK_SPACE,		0},
+	/* 3A */	{Debugger_kb::VK_CAPS,		0},
+	/* 3B */	{Debugger_kb::VK_F1,		0},
+	/* 3C */	{Debugger_kb::VK_F2,		0},
+	/* 3D */	{Debugger_kb::VK_F3,		0},
+	/* 3E */	{Debugger_kb::VK_F4,		0},
+	/* 3F */	{Debugger_kb::VK_F5,		0},
+	/* 40 */	{Debugger_kb::VK_F6,		0},
+	/* 41 */	{Debugger_kb::VK_F7,		0},
+	/* 42 */	{Debugger_kb::VK_F8,		0},
+	/* 43 */	{Debugger_kb::VK_F9,		0},
+	/* 44 */	{Debugger_kb::VK_F10,		0},
+	/* 45 */	{Debugger_kb::VK_NUM,		0},
+	/* 46 */	{Debugger_kb::VK_SCROLL,	0},
+	/* 47 */	{Debugger_kb::VK_KP7,		Debugger_kb::VK_HOME},
+	/* 48 */	{Debugger_kb::VK_KP8,		Debugger_kb::VK_UP},
+	/* 49 */	{Debugger_kb::VK_KP9,		Debugger_kb::VK_PGUP},
+	/* 4A */	{Debugger_kb::VK_KPSUB,		0},
+	/* 4B */	{Debugger_kb::VK_KP4,		Debugger_kb::VK_LEFT},
+	/* 4C */	{Debugger_kb::VK_KP5,		0},
+	/* 4D */	{Debugger_kb::VK_KP6,		Debugger_kb::VK_RIGHT},
+	/* 4E */	{Debugger_kb::VK_KPADD,		0},
+	/* 4F */	{Debugger_kb::VK_KP1,		Debugger_kb::VK_END},
+	/* 50 */	{Debugger_kb::VK_KP2,		Debugger_kb::VK_DOWN},
+	/* 51 */	{Debugger_kb::VK_KP3,		Debugger_kb::VK_PGDOWN},
+	/* 52 */	{Debugger_kb::VK_KP0,		Debugger_kb::VK_INSERT},
+	/* 53 */	{Debugger_kb::VK_KPDOT,		Debugger_kb::VK_DELETE},
+	/* 54 */	{0,							0},
+	/* 55 */	{0,							0},
+	/* 56 */	{Debugger_kb::VK_PIPE,		0},
+	/* 57 */	{Debugger_kb::VK_F11,		0},
+	/* 58 */	{Debugger_kb::VK_F12,		0},
+	/* 59 */	{0,							0},
+	/* 5A */	{0,							0},
+	/* 5B */	{0,							Debugger_kb::VK_LSUPER},
+	/* 5C */	{0,							Debugger_kb::VK_RSUPER},
+	/* 5D */	{0,							Debugger_kb::VK_APPS},
+	/* 5E */	{0,							0},
+	/* 5F */	{0,							0},
+	/* 60 */	{0,							0},
+	/* 61 */	{0,							0},
+	/* 62 */	{0,							0},
+	/* 63 */	{0,							0},
+	/* 64 */	{0,							0},
+	/* 65 */	{0,							0},
+	/* 66 */	{0,							0},
+	/* 67 */	{0,							0},
+	/* 68 */	{0,							0},
+	/* 69 */	{0,							0},
+	/* 6A */	{0,							0},
+	/* 6B */	{0,							0},
+	/* 6C */	{0,							0},
+	/* 6D */	{0,							0},
+	/* 6E */	{0,							0},
+	/* 6F */	{0,							0},
+	/* 70 */	{0,							0},
+	/* 71 */	{0,							0},
+	/* 72 */	{0,							0},
+	/* 73 */	{0,							0},
+	/* 74 */	{0,							0},
+	/* 75 */	{0,							0},
+	/* 76 */	{0,							0},
+	/* 77 */	{0,							0},
+	/* 78 */	{0,							0},
+	/* 79 */	{0,							0},
+	/* 7A */	{0,							0},
+	/* 7B */	{0,							0},
+	/* 7C */	{0,							0},
+	/* 7D */	{0,							0},
+	/* 7E */	{0,							0},
+	/* 7F */	{0,							0},
+};
+
+uint8 Debugger_kbdrv::set = 0;
+
+uint8 Debugger_kbdrv::get(uint8 *flags) {
+	uint8 scanCode,keycode;
+	ScanCodeEntry *e;
+	uint8 status = Io::in<uint8>(PORT_KB_CTRL);
+	if(!(status & STATUS_OUTBUF_FULL))
+		return Debugger_kb::VK_NOKEY;
+
+	scanCode = Io::in<uint8>(PORT_KB_DATA);
+	/* extended code-start? */
+	if(scanCode == 0xE0) {
+		set = 1;
+		return Debugger_kb::VK_NOKEY;
+	}
+
+	/* break? */
+	*flags &= ~Debugger_kb::BREAK;
+	if(scanCode & 0x80) {
+		*flags |= Debugger_kb::BREAK;
+		scanCode &= ~0x80;
+	}
+
+	/* get keycode */
+	e = map + (scanCode & 0x7F);
+	keycode = set ? e->ext : e->def;
+	set = 0;
+	return keycode;
+}
diff --git a/src/keyb.cpp b/src/keyb.cpp
index e25de54..8dad4f2 100644
--- a/src/keyb.cpp
+++ b/src/keyb.cpp
@@ -24,6 +24,7 @@
 #include "gsi.h"
 #include "keyb.h"
 #include "stdio.h"
+#include "debugger.h"
 
 unsigned Keyb::gsi = ~0u;
 
@@ -67,6 +68,9 @@ void Keyb::interrupt()
             case 0x3b ... 0x42:     // f1-f8
                 Console_vga::con.set_page (out - 0x3b);
                 break;
+            case 0x43:				// f9
+                Debugger::start();
+                break;
         }
     }
 }
diff --git a/src/lapic.cpp b/src/lapic.cpp
index 2493913..ef6f757 100644
--- a/src/lapic.cpp
+++ b/src/lapic.cpp
@@ -29,6 +29,8 @@
 unsigned    Lapic::freq_tsc;
 unsigned    Lapic::freq_bus;
 uint8       Lapic::apic_id[NUM_CPU];
+Spinlock	Lapic::spin;
+unsigned	Lapic::spincount;
 
 void Lapic::init()
 {
@@ -140,6 +142,13 @@ void Lapic::ipi_vector (unsigned vector)
     switch (vector) {
         case VEC_IPI_RRQ: Sc::rrq_handler(); break;
         case VEC_IPI_RKE: Sc::rke_handler(); break;
+        case VEC_IPI_SPIN:
+        	// say that we're here
+        	Atomic::add(spincount,1U);
+        	// wait until the lock is released
+        	spin.lock();
+        	spin.unlock();
+        	break;
     }
 
     eoi();
diff --git a/src/kobject.cpp b/src/kobject.cpp
new file mode 100644
index 0000000..35fb2b3
--- /dev/null
+++ b/src/kobject.cpp
@@ -0,0 +1,15 @@
+/*
+ * (c) 2012 Nils Asmussen <nils@os.inf.tu-dresden.de>
+ *     economic rights: Technische Universität Dresden (Germany)
+ *
+ * This file is part of TUD:OS and distributed under the terms of the
+ * GNU General Public License 2.
+ * Please see the COPYING-GPL-2 file for details.
+ */
+
+#include "kobject.h"
+
+#if ENABLE_KOBJ_LIST
+Kobject *Kobject::dbgecs[5];
+Spinlock Kobject::dbglock[5];
+#endif
-- 
1.7.9.5

